# 個人用勉強リポジトリ

rustでgRPCサーバを作ってみたくなった。  
自分の考えを整理するために色々書いてみる。

## なぜrustなのか

- go  
goroutineが優秀だが、サーバではあまり使わない気がする。  
また、rustに比べて型がガバガバで、エラーハンドリングもスマートとは言いにくい。  
バイナリを生成できるのが昨今のcontainer環境にマッチしててgood.

- java  
言語としては悪くない。またspringという強力なframeworkがある。  
ただ、圧倒的にcontainer環境と相性が悪い。jvmの起動に30秒くらいかかる。

- c#  
linuxで動かすには少々不安。言語としては良さそう(触ったことない)

- 型宣言がない言語  
私の能力不足により、型がないと動くコードが書ける気がしない。  
なるべく型の厳密な言語を勉強していきたい。

## なぜgRPCなのか

### REST(http api)が辛い
昨今、サーバ間の連携といえば、httpのgetやpostを用いたresourceのやり取りが基本。  
これを一般的にREST APIと読んでいる。

色々辛いポイントがあった。

- ドキュメント管理が煩雑になる問題  
swagger(open api v3)などがあり、ドキュメントをしっかり書こうという風潮はある。  
しかし、人間が努力して書く以上、どこかで必ず破綻する。  
それはバグに追われている時や、締め切りが近くて焦っている時が顕著である。  
gRPCではprotoファイルを書かないとコードが生成されない。  
全てのAPIはprotoに必ず記されているという安心感がある。  
また、serverとclientを同時に生成してくれるので、API, DATA共に不整合が発生しない。  
(ただし、旧verのAPIに対する考慮は依然として必要)

- RESTのURL考えるのがだるい
多くの場合RESTを使ってやりたいことは2つに分けられる。  
「データのやり取り」と「命令の発行」である。  
データのやり取りのURLを考えるのは楽。RESTの得意とするところ。  
一方で、「命令の発行」が辛い。それもリソースと考えれば設計できるが、外から見て分かりにくくなる。  
一方、gRPCはあくまでもRPCなので、処理を発行するもの。  
そう考えると、通常のメソッド名の命名と同じ感覚で付けられて気持ちが楽。

- 単純にgRPCの方が機能が多い
双方向streamingや、protobufによる圧縮など基本的に高機能

## なぜtonicなのか
今回、rustでgRPCサーバを立てるに当たって、tonicを採用した。  
理由としては、単純にstarが多いからだ。  
ただ、気に入っている点もいくつかある。

- コード生成が動的に行える
`build.rs`でコード生成するため、protoと動いているコードの不整合が起こりにくい。  
また、生成後のファイルをコミットしなくてよく、gitが綺麗になる。  
その他パフォーマンスに関しては不明。  
ただ、デメリットとして、ideに怒られ続けること。赤線が消えないので悲しくなる。

- async/awaitを使っててかっこいい  
以上

## 想定するuse case
正直、プロダクションに使えるレベルなのか判断するほどrustの知見がない。  
よって、遊び半分で立ててみるなどの使い方がメインになりそう。  
バイナリなので、起動が爆速。  
このメリットを最大限活かすため、`cloud run`等のサービスと相性が良いと感じている。
